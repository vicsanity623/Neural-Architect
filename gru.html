<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0a0a0f">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="assets/icon-192.png">
    <title>Neural Assistant Builder</title>
    <style>
        :root {
            --bg-color: #0a0a0f;
            --panel-bg: rgba(20, 20, 30, 0.8);
            --params-bg: rgba(0, 0, 0, 0.5);
            --primary: #00ffbc;
            --secondary: #00b8ff;
            --danger: #ff3366;
            --warning: #ffcc00;
            --text-main: #e0e0e0;
            --text-muted: #888;
            --font-mono: 'Menlo', 'Consolas', 'Courier New', monospace;
            --font-ui: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --radius: 12px;
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        * {
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-ui);
            margin: 0;
            padding: 20px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-image: radial-gradient(circle at 50% 10%, #1a1a2e 0%, #000 100%);
        }

        .dashboard {
            max-width: 1200px;
            width: 100%;
            height: 100%;
            margin: 0 auto;
            display: grid;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 1px;
            color: var(--primary);
            text-transform: uppercase;
        }

        .badge {
            background: rgba(0, 255, 188, 0.1);
            color: var(--primary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        .terminal-container {
            background: var(--panel-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        #terminal {
            flex: 1;
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 0.95rem;
            line-height: 1.5;
            overflow-y: auto;
            color: #d0d0d0;
            white-space: pre-wrap;
        }

        .user-line {
            color: var(--secondary);
            font-weight: bold;
        }

        .ai-line {
            color: var(--primary);
        }

        .input-area {
            display: flex;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            gap: 10px;
        }

        #input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }

        #input:focus {
            border-color: var(--secondary);
            box-shadow: 0 0 10px rgba(0, 184, 255, 0.2);
        }

        .controls {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: var(--radius);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: var(--shadow);
        }

        .stats-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .btn-group.bottom {
            margin-bottom: 0;
        }

        button {
            padding: 10px 18px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: var(--secondary);
            color: #000;
        }

        .btn-primary:hover {
            background: #33c7ff;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--primary);
            color: #000;
        }

        .btn-success:hover {
            background: #33ffcc;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: rgba(255, 51, 102, 0.1);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .btn-danger:hover {
            background: var(--danger);
            color: white;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-main);
        }

        .btn-outline:hover {
            border-color: var(--text-main);
            background: rgba(255, 255, 255, 0.05);
        }

        .metric-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 5px;
            display: block;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-main);
        }

        .progress-track {
            background: rgba(255, 255, 255, 0.1);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: var(--primary);
            transition: width 0.3s, background-color 0.3s;
        }

        details {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        summary {
            cursor: pointer;
            color: var(--secondary);
            outline: none;
            margin-bottom: 5px;
        }

        details p {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0 0 0;
            line-height: 1.6;
        }

        strong {
            color: white;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        @keyframes flash-glow {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 255, 188, 0.7);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 20px 10px rgba(0, 255, 188, 0);
                transform: scale(1.05);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 255, 188, 0);
                transform: scale(1);
            }
        }

        .flash-active {
            animation: flash-glow 0.5s ease-out;
        }

        @keyframes flash-glow-red {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 51, 102, 0.7);
                transform: scale(1);
            }

            50% {
                box-shadow: 0 0 20px 10px rgba(255, 51, 102, 0);
                transform: scale(1.05);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 51, 102, 0);
                transform: scale(1);
            }
        }

        .flash-active-red {
            animation: flash-glow-red 0.5s ease-out;
        }
    </style>
</head>

<body>
    <div class="dashboard">
        <header>
            <div>
                <h1>Neural Architect <span class="badge">v2.3 GRU</span></h1>
            </div>
            <div>
                <button class="btn-outline" onclick="clearChat()">üßπ Clear Chat</button>
                <div style="display:inline-block; width: 10px;"></div>
                <button class="btn-outline" onclick="saveBrain()">Save Brain</button>
                <button class="btn-outline" onclick="document.getElementById('file-input').click()">Load Brain</button>
                <input type="file" id="file-input" style="display: none;" onchange="loadBrain(this)">
            </div>
        </header>

        <main class="terminal-container">
            <div id="terminal">
                <div style="color: var(--text-muted); text-align: center; margin-top: 150px;">
                    GRU Context Initialized.<br>Type a message to begin conceptual training...
                </div>
            </div>
            <div class="input-area">
                <input type="text" id="input" placeholder="Type your message here..."
                    onkeypress="if(event.keyCode===13) send();" autocomplete="off">
                <button class="btn-primary" onclick="send()">Send</button>
            </div>
        </main>

        <section class="controls">
            <div class="panel">
                <div class="btn-group bottom">
                    <button id="btn-reward" class="btn-success" onclick="reward()">Reward (Good)</button>
                    <button id="btn-penalize" class="btn-danger" onclick="penalize()">Penalize (Bad)</button>
                    <div style="width: 1px; background: rgba(255,255,255,0.1); margin: 0 10px;"></div>
                    <button class="btn-outline" onclick="trainEpochs()">‚ö° Train (3 Epochs)</button>
                    <div style="display: flex; align-items: center; gap: 8px; margin-right: 10px;">
                        <input type="checkbox" id="strict-mode" style="width: 16px; height: 16px; cursor: pointer;">
                        <label for="strict-mode"
                            style="font-size: 0.75rem; color: var(--text-muted); cursor: pointer; text-transform: none;">Strict
                            Mode</label>
                    </div>
                    <button id="btn-auto" class="btn-outline" onclick="autoTrain()">ü§ñ Auto Teach</button>
                    <button class="btn-danger" style="margin-left: auto;" onclick="resetBrain()">Reset Brain</button>
                </div>

                <details>
                    <summary><strong>üìö How to Teach (Guide)</strong></summary>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 6px; margin-top: 10px;">
                        <h4 style="margin: 0 0 10px 0; color: var(--secondary); font-size: 0.9rem;">Manual Training</h4>
                        <ol style="margin: 0 0 15px 0; padding-left: 20px; line-height: 1.6; font-size: 0.85rem;">
                            <li><strong>Chat</strong>: Type a message and hit Send.</li>
                            <li><strong>Feedback</strong>: If the AI is wrong, click <strong>Penalize</strong> and enter
                                the correction.</li>
                            <li><strong>Cement</strong>: Click <strong>‚ö° Train</strong> to run 3 light epochs on that
                                correction.</li>
                        </ol>

                        <h4 style="margin: 0 0 10px 0; color: var(--secondary); font-size: 0.9rem;">ü§ñ Auto Training
                            (Bulk Learning)</h4>
                        <ol style="margin: 0; padding-left: 20px; line-height: 1.6; font-size: 0.85rem;">
                            <li><strong>Prepare</strong>: Click <strong>Auto Train</strong> and paste pairs as
                                <code>Trigger|Response</code>.
                            </li>
                            <li><strong>Variations</strong>: Support multi-answers (e.g.
                                <code>Hello|Hi,Hi there</code>).
                            </li>
                            <li><strong>Monitor</strong>: The AI self-corrects through the list until it hits "Mastery".
                            </li>
                            <li><strong>Success</strong>: Reaching 85% accuracy over 3 loops triggers a final
                                optimization phase.</li>
                        </ol>
                        <p
                            style="margin-top: 15px; font-size: 0.8rem; color: var(--text-muted); border-top: 1px solid rgba(255,255,255,0.05); padding-top: 10px;">
                            <strong>Tip</strong>: Aim for a Loss Value &lt; 1.0 for reliable, human-like responses.
                        </p>
                    </div>
                </details>
            </div>

            <div class="panel stats-panel">
                <div
                    style="margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 10px;">
                    <span class="metric-label">Creativity (Temperature)</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="temp-slider" min="0.1" max="2.0" step="0.1" value="0.7"
                            style="flex: 1; accent-color: var(--secondary);"
                            oninput="document.getElementById('temp-val').innerText = this.value">
                        <span id="temp-val" class="metric-value" style="font-size: 1rem; width: 30px;">0.7</span>
                    </div>
                </div>

                <span class="metric-label">Current Loss Value (Confusion Assessment)</span>
                <div style="display: flex; justify-content: space-between; align-items: baseline;">
                    <span class="metric-value" id="loss-display">--.----</span>
                    <span id="loss-info" style="font-size: 0.8rem; color: var(--text-muted);">Lower is Better</span>
                </div>
                <div class="progress-track">
                    <div id="loss-bar" class="progress-fill"></div>
                </div>
                <div id="auto-score"
                    style="margin-top: 10px; font-size: 0.75rem; color: var(--text-muted); display: none;">
                    <span style="color: #00ffbc;">‚úì Rewards: <span id="reward-count">0</span></span> |
                    <span style="color: #ff3366;">‚úó Penalties: <span id="penalty-count">0</span></span> |
                    <span>Loops: <span id="loop-count">0</span></span> |
                    <span style="color: gold;">Mastery: <span id="mastery-percent">0</span>%</span> |
                    <span style="color: var(--secondary);">Variant: <span id="variant-indicator">0/0</span></span> |
                    <span style="color: #ffcc00;">Active: <span id="curriculum-indicator">0/0</span></span>
                </div>

                <div id="tech-stats"
                    style="margin-top: 10px; font-size: 0.75rem; color: var(--text-muted); display: flex; flex-wrap: wrap; gap: 5px 10px;">
                    <span style="color: #00b8ff;">Params: <span id="param-count">--</span></span>
                    <span style="color: #ff66ff;">Vocab: <span id="vocab-size">--</span></span>
                    <span style="color: #ff33ff;">Grad Norm: <span id="grad-norm">0.000000000</span></span>
                    <span style="color: #ffcc00;">Loss: <span id="loss-tech">0.000000000</span></span>
                    <span style="color: #00ff00;">Memory: <span id="replay-count">0</span></span>
                </div>
            </div>
        </section>
    </div>

    <script>
        window.onerror = function (msg, url, line, col, error) {
            alert("Error: " + msg + "\nLine: " + line + "\nCol: " + col + "\nStack: " + (error ? error.stack : "n/a"));
            let btn = document.querySelector('button[onclick="send()"]');
            if (btn) btn.innerText = "Send";
        };
        window.onunhandledrejection = function (e) {
            alert("Unhandled Promise Rejection: " + e.reason);
        };



        function createMatrix(rows, cols, value = 0) {
            let m = new Array(rows);
            for (let i = 0; i < rows; i++) {
                m[i] = new Array(cols).fill(value);
            }
            return m;
        }

        function createRandomMatrix(rows, cols) {
            let m = new Array(rows);
            let scale = Math.sqrt(2.0 / (rows + cols));
            for (let i = 0; i < rows; i++) {
                m[i] = new Array(cols);
                for (let j = 0; j < cols; j++) {
                    m[i][j] = (Math.random() * 2 - 1) * scale;
                }
            }
            return m;
        }

        function matmul(a, b) {
            let rowsA = a.length, colsA = a[0].length, rowsB = b.length, colsB = b[0].length;
            if (colsA !== rowsB) throw new Error("Matrix dimensions mismatch");
            let result = createMatrix(rowsA, colsB, 0);
            for (let i = 0; i < rowsA; i++) {
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += a[i][k] * b[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }

        function addMatrix(a, b) {
            let rows = a.length, cols = a[0].length;
            let result = createMatrix(rows, cols, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[i][j] = a[i][j] + b[i][j];
                }
            }
            return result;
        }

        function subtractMatrix(a, b) {
            let rows = a.length, cols = a[0].length;
            let result = createMatrix(rows, cols, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[i][j] = a[i][j] - b[i][j];
                }
            }
            return result;
        }

        function multiplyMatrix(a, b) {
            let rows = a.length, cols = a[0].length;
            let result = createMatrix(rows, cols, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[i][j] = a[i][j] * b[i][j];
                }
            }
            return result;
        }

        function scaleMatrix(s, a) {
            let rows = a.length, cols = a[0].length;
            let result = createMatrix(rows, cols, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[i][j] = s * a[i][j];
                }
            }
            return result;
        }

        function transpose(a) {
            let rows = a.length, cols = a[0].length;
            let result = createMatrix(cols, rows, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[j][i] = a[i][j];
                }
            }
            return result;
        }

        function mapMatrix(m, func) {
            let rows = m.length, cols = m[0].length;
            let result = createMatrix(rows, cols, 0);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    result[i][j] = func(m[i][j]);
                }
            }
            return result;
        }

        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }

        function dsigmoid(y) {
            return y * (1 - y);
        }

        function dtanh(y) {
            return 1 - y * y;
        }

        function softmax(m) {
            let arr = m.map(row => row[0]);
            let max = Math.max(...arr);
            let exps = arr.map(v => Math.exp(v - max));
            let sum = exps.reduce((acc, v) => acc + v, 0);
            let soft = exps.map(v => v / sum);
            return soft.map(v => [v]);
        }

        function argmax(arr) {
            let max = arr[0];
            let maxIndex = 0;
            for (let i = 1; i < arr.length; i++) {
                if (arr[i] > max) {
                    max = arr[i];
                    maxIndex = i;
                }
            }
            return maxIndex;
        }

        function sample(probs) {
            let sum = 0;
            let r = Math.random();
            for (let i = 0; i < probs.length; i++) {
                sum += probs[i];
                if (r < sum) return i;
            }
            return probs.length - 1;
        }

        function fromArray(arr) {
            return arr.map(v => [v]);
        }

        function toArray(m) {
            return m.map(row => row[0]);
        }





        class GRU {
            constructor(vocabSize, hiddenSize, embedSize) {
                this.vocabSize = vocabSize;
                this.hiddenSize = hiddenSize;
                this.embedSize = embedSize;
                this.learning_rate = 0.0005;


                this.Embed = createRandomMatrix(this.embedSize, this.vocabSize);


                let concatSize = this.embedSize + this.hiddenSize;


                this.Wz = createRandomMatrix(this.hiddenSize, concatSize);
                this.bz = createMatrix(this.hiddenSize, 1, 0);


                this.Wr = createRandomMatrix(this.hiddenSize, concatSize);
                this.br = createMatrix(this.hiddenSize, 1, 0);


                this.Wh = createRandomMatrix(this.hiddenSize, concatSize);
                this.bh = createMatrix(this.hiddenSize, 1, 0);


                this.Why = createRandomMatrix(this.vocabSize, this.hiddenSize);
                this.by = createMatrix(this.vocabSize, 1, 0);


                this.m = {};
                this.v = {};
                this.t = 0;
                this.beta1 = 0.9;
                this.beta2 = 0.999;
                this.eps = 1e-8;


                let keys = ['Wz', 'bz', 'Wr', 'br', 'Wh', 'bh', 'Why', 'by', 'Embed'];
                keys.forEach(k => {
                    this.m[k] = createMatrix(this[k].length, this[k][0].length, 0);
                    this.v[k] = createMatrix(this[k].length, this[k][0].length, 0);
                });
            }


            getEmbedding(idx) {
                let vec = createMatrix(this.embedSize, 1);
                for (let i = 0; i < this.embedSize; i++) {
                    vec[i][0] = this.Embed[i][idx];
                }
                return vec;
            }

            getParameterCount() {
                return (this.embedSize * this.vocabSize) +
                    3 * (this.hiddenSize * (this.embedSize + this.hiddenSize + 1)) +
                    (this.vocabSize * (this.hiddenSize + 1));
            }

            forward(inputs) {
                let h = createMatrix(this.hiddenSize, 1, 0);
                let caches = [];
                let outputs = [];

                for (let t = 0; t < inputs.length; t++) {
                    let tokenIdx = inputs[t];

                    let x = this.getEmbedding(tokenIdx);


                    let concat = new Array(this.embedSize + this.hiddenSize);
                    for (let i = 0; i < this.embedSize; i++) concat[i] = x[i];
                    for (let i = 0; i < this.hiddenSize; i++) concat[this.embedSize + i] = h[i];


                    let xh = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let i = 0; i < xh.length; i++) xh[i][0] = concat[i][0];


                    let zraw = addMatrix(matmul(this.Wz, xh), this.bz);
                    let z = mapMatrix(zraw, sigmoid);


                    let rraw = addMatrix(matmul(this.Wr, xh), this.br);
                    let r = mapMatrix(rraw, sigmoid);



                    let rh = multiplyMatrix(r, h);

                    let concat_cand = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let i = 0; i < this.embedSize; i++) concat_cand[i][0] = x[i][0];
                    for (let i = 0; i < this.hiddenSize; i++) concat_cand[this.embedSize + i][0] = rh[i][0];

                    let h_cand_raw = addMatrix(matmul(this.Wh, concat_cand), this.bh);
                    let h_cand = mapMatrix(h_cand_raw, Math.tanh);


                    let ones = createMatrix(this.hiddenSize, 1, 1);
                    let z_inv = subtractMatrix(ones, z);
                    let term1 = multiplyMatrix(z_inv, h);
                    let term2 = multiplyMatrix(z, h_cand);
                    let h_new = addMatrix(term1, term2);


                    caches.push({
                        h_prev: h, x, xh, z, r, h_cand, rh, tokenIdx, concat_cand
                    });

                    h = h_new;


                    let o = addMatrix(matmul(this.Why, h), this.by);
                    outputs.push(softmax(o));
                }

                return { outputs, caches, lastHidden: h };
            }

            train(inputs, targets) {
                let { outputs, caches } = this.forward(inputs);
                let loss = 0;


                let dEmbed = createMatrix(this.embedSize, this.vocabSize, 0);
                let dWz = createMatrix(this.hiddenSize, this.embedSize + this.hiddenSize, 0);
                let dWr = createMatrix(this.hiddenSize, this.embedSize + this.hiddenSize, 0);
                let dWh = createMatrix(this.hiddenSize, this.embedSize + this.hiddenSize, 0);
                let dbz = createMatrix(this.hiddenSize, 1, 0);
                let dbr = createMatrix(this.hiddenSize, 1, 0);
                let dbh = createMatrix(this.hiddenSize, 1, 0);
                let dWhy = createMatrix(this.vocabSize, this.hiddenSize, 0);
                let dby = createMatrix(this.vocabSize, 1, 0);

                let dh_next = createMatrix(this.hiddenSize, 1, 0);


                let smoothing = 0.1;
                let conf = 1.0 - smoothing;
                let smoothVal = smoothing / (this.vocabSize - 1);

                for (let t = outputs.length - 1; t >= 0; t--) {
                    let targetIdx = targets[t];
                    let probs = toArray(outputs[t]);
                    loss += -Math.log(Math.max(probs[targetIdx], 1e-10));


                    let dy = createMatrix(this.vocabSize, 1, 0);
                    for (let i = 0; i < this.vocabSize; i++) {
                        let targetV = (i === targetIdx) ? conf : smoothVal;
                        dy[i][0] = probs[i] - targetV;
                    }


                    let h_curr = (t < outputs.length - 1) ? caches[t + 1].h_prev : caches[t].h_prev;





                    let c = caches[t];
                    let ones = createMatrix(this.hiddenSize, 1, 1);
                    let z_inv = subtractMatrix(ones, c.z);
                    let h_new = addMatrix(multiplyMatrix(z_inv, c.h_prev), multiplyMatrix(c.z, c.h_cand));

                    dWhy = addMatrix(dWhy, matmul(dy, transpose(h_new)));
                    dby = addMatrix(dby, dy);


                    let dh = matmul(transpose(this.Why), dy);
                    dh = addMatrix(dh, dh_next);





                    let dh_cand = multiplyMatrix(dh, c.z);
                    let dtanh_term = mapMatrix(c.h_cand, dtanh);
                    let d_raw_cand = multiplyMatrix(dh_cand, dtanh_term);


                    dWh = addMatrix(dWh, matmul(d_raw_cand, transpose(c.concat_cand)));
                    dbh = addMatrix(dbh, d_raw_cand);



                    let d_concat_cand = matmul(transpose(this.Wh), d_raw_cand);

                    let d_rh = createMatrix(this.hiddenSize, 1);
                    let d_x_1 = createMatrix(this.embedSize, 1);
                    for (let i = 0; i < this.embedSize; i++) d_x_1[i][0] = d_concat_cand[i][0];
                    for (let i = 0; i < this.hiddenSize; i++) d_rh[i][0] = d_concat_cand[this.embedSize + i][0];

                    let dr = multiplyMatrix(d_rh, c.h_prev);
                    let d_raw_r = multiplyMatrix(dr, mapMatrix(c.r, dsigmoid));

                    dWr = addMatrix(dWr, matmul(d_raw_r, transpose(c.xh)));
                    dbr = addMatrix(dbr, d_raw_r);




                    let dterm1 = multiplyMatrix(dh, scaleMatrix(-1, c.h_prev));
                    let dterm2 = multiplyMatrix(dh, c.h_cand);
                    let dz = addMatrix(dterm1, dterm2);
                    let d_raw_z = multiplyMatrix(dz, mapMatrix(c.z, dsigmoid));

                    dWz = addMatrix(dWz, matmul(d_raw_z, transpose(c.xh)));
                    dbz = addMatrix(dbz, d_raw_z);



                    let dh_prev_1 = multiplyMatrix(dh, z_inv);

                    let dh_prev_2 = multiplyMatrix(d_rh, c.r);

                    let dz_xh = matmul(transpose(this.Wz), d_raw_z);
                    let dr_xh = matmul(transpose(this.Wr), d_raw_r);


                    let dh_prev_3 = createMatrix(this.hiddenSize, 1);
                    let dh_prev_4 = createMatrix(this.hiddenSize, 1);
                    for (let i = 0; i < this.hiddenSize; i++) {
                        dh_prev_3[i][0] = dz_xh[this.embedSize + i][0];
                        dh_prev_4[i][0] = dr_xh[this.embedSize + i][0];
                    }

                    dh_next = addMatrix(addMatrix(dh_prev_1, dh_prev_2), addMatrix(dh_prev_3, dh_prev_4));



                    let dx_z = createMatrix(this.embedSize, 1);
                    let dx_r = createMatrix(this.embedSize, 1);
                    for (let i = 0; i < this.embedSize; i++) {
                        dx_z[i][0] = dz_xh[i][0];
                        dx_r[i][0] = dr_xh[i][0];
                    }
                    let dx = addMatrix(addMatrix(dx_z, dx_r), d_x_1);


                    for (let i = 0; i < this.embedSize; i++) {
                        dEmbed[i][c.tokenIdx] += dx[i][0];
                    }
                }


                let totalGradNorm = 0;
                let grads = { Wz: dWz, Wr: dWr, Wh: dWh, Why: dWhy, bz: dbz, br: dbr, bh: dbh, by: dby, Embed: dEmbed };

                for (let key in grads) {
                    let m = grads[key];
                    for (let i = 0; i < m.length; i++) {
                        for (let j = 0; j < m[i].length; j++) {
                            totalGradNorm += m[i][j] * m[i][j];
                        }
                    }
                }
                totalGradNorm = Math.sqrt(totalGradNorm);

                let maxNorm = 5.0;
                if (totalGradNorm > maxNorm) {
                    let scale = maxNorm / totalGradNorm;
                    for (let key in grads) {
                        grads[key] = scaleMatrix(scale, grads[key]);
                    }
                }


                if (isNaN(totalGradNorm) || totalGradNorm === Infinity) {
                    console.warn("‚ö†Ô∏è Exploding Gradient detected! Skipping update.");
                    return { loss: loss / outputs.length, gradNorm: 0 };
                }

                // Adam Update
                this.t++;
                let intensity = arguments[2] || 1.0;
                let lr = this.learning_rate * intensity;

                let bc1 = 1 - Math.pow(this.beta1, this.t);
                let bc2 = 1 - Math.pow(this.beta2, this.t);

                for (let key in grads) {
                    let param = this[key];
                    let grad = grads[key];
                    let m = this.m[key];
                    let v = this.v[key];

                    for (let i = 0; i < param.length; i++) {
                        for (let j = 0; j < param[i].length; j++) {
                            let g = grad[i][j];
                            m[i][j] = this.beta1 * m[i][j] + (1 - this.beta1) * g;
                            v[i][j] = this.beta2 * v[i][j] + (1 - this.beta2) * g * g;

                            let m_hat = m[i][j] / bc1;
                            let v_hat = v[i][j] / bc2;

                            // Check for NaN in parameter update
                            let update = lr * m_hat / (Math.sqrt(v_hat) + this.eps);
                            if (!isNaN(update)) {
                                param[i][j] -= update;
                            }
                        }
                    }
                }

                return { loss: loss / outputs.length, gradNorm: totalGradNorm };
            }

            generate(startTokens, maxLen) {
                let temp = parseFloat(document.getElementById('temp-slider').value) || 0.7;
                let h = createMatrix(this.hiddenSize, 1, 0);


                for (let t = 0; t < startTokens.length; t++) {
                    let tokenIdx = startTokens[t];
                    let x = this.getEmbedding(tokenIdx);

                    let concat = new Array(this.embedSize + this.hiddenSize);
                    for (let i = 0; i < this.embedSize; i++) concat[i] = x[i];
                    for (let i = 0; i < this.hiddenSize; i++) concat[this.embedSize + i] = h[i];
                    let xh = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let i = 0; i < xh.length; i++) xh[i][0] = concat[i][0];

                    let z = mapMatrix(addMatrix(matmul(this.Wz, xh), this.bz), sigmoid);
                    let r = mapMatrix(addMatrix(matmul(this.Wr, xh), this.br), sigmoid);

                    let rh = multiplyMatrix(r, h);
                    let concat_cand = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let i = 0; i < this.embedSize; i++) concat_cand[i][0] = x[i][0];
                    for (let i = 0; i < this.hiddenSize; i++) concat_cand[this.embedSize + i][0] = rh[i][0];

                    let h_cand = mapMatrix(addMatrix(matmul(this.Wh, concat_cand), this.bh), Math.tanh);

                    let ones = createMatrix(this.hiddenSize, 1, 1);
                    let z_inv = subtractMatrix(ones, z);
                    h = addMatrix(multiplyMatrix(z_inv, h), multiplyMatrix(z, h_cand));
                }

                let generatedIndices = [];
                let currentIdx = startTokens[startTokens.length - 1];

                for (let i = 0; i < maxLen; i++) {
                    let o = addMatrix(matmul(this.Why, h), this.by);


                    let logits = toArray(o).map(v => v / temp);



                    let frequency = {};
                    generatedIndices.forEach(id => {
                        frequency[id] = (frequency[id] || 0) + 1;
                    });

                    Object.keys(frequency).forEach(prevIdxStr => {
                        let prevIdx = parseInt(prevIdxStr);
                        let count = frequency[prevIdx];

                        logits[prevIdx] -= (1.5 + (count * 2.0));
                    });


                    if (generatedIndices.length < 5) {
                        let endIdx = getIndex(END_TOKEN);
                        if (endIdx !== -1) logits[endIdx] -= 5.0;
                    }


                    vocab.forEach((w, idx) => {
                        if (w === "<RESERVED>" || w === UNK_TOKEN || w === START_TOKEN) {
                            logits[idx] = -1e10;
                        }
                    });

                    let maxLogit = Math.max(...logits);
                    let exps = logits.map(v => Math.exp(v - maxLogit));
                    let sum = exps.reduce((a, b) => a + b, 0);
                    let probs = exps.map(v => v / sum);

                    let nextIdx = sample(probs);
                    let word = vocab[nextIdx];

                    generatedIndices.push(nextIdx);
                    if (word === END_TOKEN) break;

                    currentIdx = nextIdx;


                    let x = this.getEmbedding(currentIdx);
                    let concat = new Array(this.embedSize + this.hiddenSize);
                    for (let j = 0; j < this.embedSize; j++) concat[j] = x[j];
                    for (let j = 0; j < this.hiddenSize; j++) concat[this.embedSize + j] = h[j];
                    let xh = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let j = 0; j < xh.length; j++) xh[j][0] = concat[j][0];

                    let z = mapMatrix(addMatrix(matmul(this.Wz, xh), this.bz), sigmoid);
                    let r = mapMatrix(addMatrix(matmul(this.Wr, xh), this.br), sigmoid);
                    let rh = multiplyMatrix(r, h);
                    let concat_cand = createMatrix(this.embedSize + this.hiddenSize, 1);
                    for (let j = 0; j < this.embedSize; j++) concat_cand[j][0] = x[j][0];
                    for (let j = 0; j < this.hiddenSize; j++) concat_cand[this.embedSize + j][0] = rh[j][0];
                    let h_cand = mapMatrix(addMatrix(matmul(this.Wh, concat_cand), this.bh), Math.tanh);
                    let ones = createMatrix(this.hiddenSize, 1, 1);
                    let z_inv = subtractMatrix(ones, z);
                    h = addMatrix(multiplyMatrix(z_inv, h), multiplyMatrix(z, h_cand));
                }
                return generatedIndices;
            }
        }




        const START_TOKEN = "<START>";
        const END_TOKEN = "<END>";
        const UNK_TOKEN = "<UNK>";


        let vocab = [
            START_TOKEN, END_TOKEN, UNK_TOKEN,
            "hello", "hi", "hey", "i", "am", "you", "are", "is", "what",
            "who", "name", "good", "bad", "yes", "no", "assistant", "ai",
            "neural", "network", "train", "learning", "thanks", "please",
            ".", "?", "!", ",", ".]",
            "a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
            "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
        ];
        let wordToIdx = {};
        vocab.forEach((w, i) => wordToIdx[w] = i);

        function tokenize(text) {
            // Split by punctuation and spaces
            let rawWords = text
                .replace(/([.,!?;:])/g, ' $1 ')
                .split(/\s+/)
                .filter(w => w.length > 0);

            let tokens = [];
            rawWords.forEach(w => {
                // 1. Try Lowercase Match (The Fix)
                let lower = w.toLowerCase();

                // If the lowercase version exists in our dictionary, use it!
                if (wordToIdx[lower] !== undefined) {
                    tokens.push(lower);
                }
                // 2. Fallback to Characters (Only if strictly necessary)
                else if (vocab.length < VOCAB_CAPACITY - 100) {
                    let chars = w.split('');
                    tokens.push(...chars);
                }
                // 3. Last Resort: UNK
                else {
                    tokens.push(UNK_TOKEN);
                }
            });
            return tokens;
        }

        function getIndex(word) {
            if (wordToIdx[word] !== undefined) return wordToIdx[word];


            let slot = vocab.findIndex(w => w === "<RESERVED>");
            if (slot !== -1) {
                vocab[slot] = word;
                wordToIdx[word] = slot;
                return slot;
            }
            return wordToIdx[UNK_TOKEN];
        }



        const VOCAB_CAPACITY = 5000;
        const EMBED_SIZE = 64;
        const HIDDEN_SIZE = 512;


        while (vocab.length < VOCAB_CAPACITY) {
            vocab.push("<RESERVED>");
        }

        wordToIdx = {};
        vocab.forEach((w, i) => wordToIdx[w] = i);

        let rnn = new GRU(VOCAB_CAPACITY, HIDDEN_SIZE, EMBED_SIZE);

        let historyTokens = [];
        let trainingBuffer = [];
        let historyTextDisplay = '';
        let lastLoss = 0.0;
        let smoothLoss = 0.0;
        let replayBuffer = [];
        let isAutoTraining = false;
        let trainingQueue = [];
        let currentPairIndex = 0;
        let consecutiveWins = 0;
        let autoLoopCount = 0;
        let rewardCount = 0;
        let penaltyCount = 0;
        let currentVariantIndex = 0;
        let isCurriculumMode = false;
        let curriculumLimit = 1;
        let lastResponseTokenCount = 0;

        async function send() {
            try {
                let userMsg = document.getElementById('input').value.trim();
                if (userMsg === '') return;

                let btn = document.querySelector('button[onclick="send()"]');
                let originalText = btn.innerText;
                btn.innerText = "Thinking...";
                await new Promise(r => setTimeout(r, 10));

                document.getElementById('input').value = '';

                if (historyTextDisplay === '') {
                    document.getElementById('terminal').innerHTML = '';
                    historyTokens = [];
                    trainingBuffer = [];
                }


                let uTokens = tokenize(userMsg);


                if (historyTokens.length > 0) historyTokens.push(getIndex(".]"));
                if (trainingBuffer.length > 0) trainingBuffer.push(getIndex(".]"));

                uTokens.forEach(w => {
                    let idx = getIndex(w);
                    historyTokens.push(idx);
                    trainingBuffer.push(idx);
                });

                let userLine = `<span class="user-line">User:</span> ${userMsg}`;
                let newHistoryDisplay = (document.getElementById('terminal').innerHTML + '\n' + userLine).trim();
                updateTerminalHTML(newHistoryDisplay + '\n<span class="ai-line">Assistant:</span> ...');
                await new Promise(r => setTimeout(r, 10));


                let genIndices = rnn.generate(historyTokens, 50);
                lastResponseTokenCount = 0;

                let responseWords = [];
                for (let idx of genIndices) {
                    let w = vocab[idx];

                    if (w === START_TOKEN || w === "<RESERVED>" || w === UNK_TOKEN || w === ".]") continue;
                    if (w === END_TOKEN) break;
                    responseWords.push(w);

                    historyTokens.push(idx);
                    trainingBuffer.push(idx);

                    lastResponseTokenCount++;
                    if (w === '.' || w === '?' || w === '!') break;
                }



                trainingBuffer.push(getIndex(END_TOKEN));

                historyTokens.push(getIndex(END_TOKEN));
                lastResponseTokenCount++;

                // --- NEW DETOKENIZER LOGIC START ---
                // Old way: let response = responseWords.join(' ').replace...

                let response = "";
                for (let i = 0; i < responseWords.length; i++) {
                    let w = responseWords[i];
                    response += w;

                    // Look ahead: Should we add a space?
                    if (i < responseWords.length - 1) {
                        let nextW = responseWords[i + 1];
                        // Heuristic: If Current AND Next are single letters/numbers, don't space.
                        // This glues "H" "e" "l" "l" "o" -> "Hello"
                        let currIsChar = w.length === 1 && /^[a-zA-Z0-9]$/.test(w);
                        let nextIsChar = nextW.length === 1 && /^[a-zA-Z0-9]$/.test(nextW);

                        if (!currIsChar || !nextIsChar) {
                            response += " ";
                        }
                    }
                }
                // Cleanup punctuation (fix "Hello ." -> "Hello.")
                response = response.replace(/ ([.,!?;:])/g, '$1');

                // --- NEW DETOKENIZER LOGIC END ---

                if (response === '') response = "...";

                historyTextDisplay += 'User: ' + userMsg + '\nAssistant: ' + response + '\n';

                let finalDisplay = newHistoryDisplay + `\n<span class="ai-line">Assistant:</span> ${response}`;
                updateTerminalHTML(finalDisplay);


                updateTechStats();

                btn.innerText = originalText;
            } catch (e) {
                alert("Error in send(): " + e.message);
                console.error(e);
            }
        }

        function updateTerminalHTML(htmlContent) {
            let term = document.getElementById('terminal');
            term.innerHTML = htmlContent.replace(/\n/g, '<br>');
            term.scrollTop = term.scrollHeight;
        }


        async function reward() {
            let btn = document.getElementById('btn-reward');
            btn.classList.add('flash-active');
            setTimeout(() => btn.classList.remove('flash-active'), 500);
            await new Promise(r => setTimeout(r, 100));


            for (let i = 0; i < 2; i++) {
                trainOnHistory(1.0);
                if (i < 1) await new Promise(r => setTimeout(r, 0));
            }


            if (trainingBuffer.length >= 4) {
                let start = Math.max(0, trainingBuffer.length - 20);
                replayBuffer.push({
                    inputs: [getIndex(START_TOKEN), ...trainingBuffer.slice(start, trainingBuffer.length - 1)],
                    targets: [...trainingBuffer.slice(start + 1, trainingBuffer.length - 1), getIndex(END_TOKEN)]
                });
                if (replayBuffer.length > 5000) replayBuffer.shift();
            }
        }

        async function penalize(forcedCorrection = null) {
            let btn = document.getElementById('btn-penalize');
            btn.classList.add('flash-active-red');
            setTimeout(() => btn.classList.remove('flash-active-red'), 500);
            await new Promise(r => setTimeout(r, 100));

            let correct = forcedCorrection;
            if (correct === null) correct = prompt('What should the response be?');
            if (correct == null || correct.trim() === '') return;


            for (let i = 0; i < lastResponseTokenCount; i++) {
                historyTokens.pop();
                trainingBuffer.pop();
            }
            lastResponseTokenCount = 0;


            let correctTokens = tokenize(correct);

            let term = document.getElementById('terminal');
            let html = term.innerHTML;
            let lastAiIndex = html.lastIndexOf('<span class="ai-line">Assistant:</span>');
            if (lastAiIndex > -1) {
                term.innerHTML = html.substring(0, lastAiIndex) + `<span class="ai-line">Assistant:</span> ${correct}`;
            }

            correctTokens.forEach(w => {
                let idx = wordToIdx[w];
                if (idx === undefined) idx = wordToIdx[UNK_TOKEN];
                historyTokens.push(idx);
                trainingBuffer.push(idx);
            });

            historyTokens.push(getIndex(END_TOKEN));
            trainingBuffer.push(getIndex(END_TOKEN));


            for (let i = 0; i < 3; i++) {
                trainOnHistory(1.5);
                await new Promise(r => setTimeout(r, 0));
            }


            let start = Math.max(0, trainingBuffer.length - 15);
            replayBuffer.push({
                inputs: [getIndex(START_TOKEN), ...trainingBuffer.slice(start, trainingBuffer.length - 1)],
                targets: [...trainingBuffer.slice(start + 1, trainingBuffer.length), getIndex(END_TOKEN)]
            });
            if (replayBuffer.length > 5000) replayBuffer.shift();
        }

        let lastGradNorm = 0.0;
        function trainOnHistory(intensity = 1.0) {

            let start = Math.max(0, trainingBuffer.length - 40);
            let subset = trainingBuffer.slice(start);

            let totalLoss = 0;
            let count = 0;


            if (subset.length >= 2) {

                let inputs = [getIndex(START_TOKEN), ...subset.slice(0, subset.length - 1)];
                let targets = [...subset.slice(1), getIndex(END_TOKEN)];

                let result = rnn.train(inputs, targets, intensity);
                lastGradNorm = result.gradNorm;
                totalLoss += result.loss;
                count++;
            }


            if (replayBuffer.length > 0) {
                let idx = Math.floor(Math.random() * replayBuffer.length);
                let sample = replayBuffer[idx];
                let result = rnn.train(sample.inputs, sample.targets, intensity * 0.5);
                totalLoss += result.loss;
                count++;
            }

            if (count > 0) {
                let avgLoss = totalLoss / count;
                updateLossUI(avgLoss);
                return avgLoss;
            }
            return 0;
        }

        function updateLossUI(loss) {
            // 1. Sanity Check: If the incoming loss is garbage, ignore it.
            if (isNaN(loss) || !isFinite(loss)) {
                return;
            }

            lastLoss = loss;

            // 2. Auto-Recovery: If the display is currently stuck on NaN, reset it.
            if (isNaN(smoothLoss) || !isFinite(smoothLoss) || smoothLoss === 0) {
                smoothLoss = loss;
            } else {
                // Normal smoothing
                smoothLoss = smoothLoss * 0.9 + loss * 0.1;
            }

            document.getElementById('loss-display').innerText = smoothLoss.toFixed(9);

            // Visual Bar Logic
            let percent = Math.max(0, Math.min(100, (1 - (smoothLoss / 5)) * 100));
            document.getElementById('loss-bar').style.width = percent + "%";
            document.getElementById('loss-bar').style.backgroundColor = smoothLoss < 1.0 ? '#0f0' : (smoothLoss < 3.0 ? '#ff0' : '#f00');

            updateTechStats();
        }

        function updateTechStats() {
            let count = rnn.getParameterCount();
            let display = count >= 1000000 ? (count / 1000000).toFixed(2) + "M" : (count / 1000).toFixed(0) + "k";
            document.getElementById('param-count').innerText = display;
            let usedVocab = vocab.filter(w => w !== "<RESERVED>").length;
            document.getElementById('vocab-size').innerText = usedVocab + " / " + VOCAB_CAPACITY;
            document.getElementById('grad-norm').innerText = lastGradNorm.toFixed(9);
            document.getElementById('loss-tech').innerText = lastLoss.toFixed(9);
            document.getElementById('replay-count').innerText = replayBuffer.length;
        }

        async function trainEpochs() {
            let btn = document.querySelector('button[onclick="trainEpochs()"]');
            btn.innerText = "Training...";
            await new Promise(r => setTimeout(r, 10));
            try {
                for (let i = 0; i < 3; i++) {
                    trainOnHistory(2.0);
                    if (i % 2 === 0) await new Promise(r => setTimeout(r, 0));
                }
            } finally {
                btn.innerText = "‚ö° Train (3 Epochs)";
            }
        }

        function saveBrain() {
            let data = {
                vocab: vocab,
                rnn: {
                    Embed: rnn.Embed,
                    Wz: rnn.Wz, bz: rnn.bz,
                    Wr: rnn.Wr, br: rnn.br,
                    Wh: rnn.Wh, bh: rnn.bh,
                    Why: rnn.Why, by: rnn.by
                }
            };
            let blob = new Blob([JSON.stringify(data)], { type: "application/json" });
            let a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "gru_brain_v2.json";
            a.click();
        }

        function loadBrain(input) {
            let file = input.files[0];
            if (!file) return;
            let reader = new FileReader();
            reader.onload = function (e) {
                try {
                    let data = JSON.parse(e.target.result);

                    vocab = data.vocab;
                    wordToIdx = {};
                    vocab.forEach((w, i) => wordToIdx[w] = i);


                    rnn.Embed = data.rnn.Embed;
                    rnn.Wz = data.rnn.Wz; rnn.bz = data.rnn.bz;
                    rnn.Wr = data.rnn.Wr; rnn.br = data.rnn.br;
                    rnn.Wh = data.rnn.Wh; rnn.bh = data.rnn.bh;
                    rnn.Why = data.rnn.Why; rnn.by = data.rnn.by;

                    alert("Brain v2 loaded!");
                } catch (err) {
                    alert("Error: " + err.message);
                }
            };
            reader.readAsText(file);
        }

        function resetBrain() {
            if (!confirm("Reset Brain?")) return;
            location.reload();
        }

        function clearChat() {
            historyTokens = [];
            document.getElementById('terminal').innerHTML = '<div style="color:var(--text-muted);text-align:center;margin-top:150px;">Chat Cleared.<br>Memory Intact.</div>';
        }


        async function autoTrain() {
            if (isAutoTraining) {
                isAutoTraining = false;
                document.getElementById('btn-auto').innerText = "ü§ñ Auto Train";
                return;
            }
            let input = prompt("Enter pairs: Trigger|Response");
            if (!input) return;

            trainingQueue = [];
            let rawPairs = input.split(/[\n;]+/);
            for (let p of rawPairs) {
                if (!p.includes('|')) continue;
                let parts = p.split('|');
                if (parts.length >= 2) {
                    let targetString = parts[1].trim();
                    let variants = targetString.split(',').map(v => v.trim()).filter(v => v !== '');
                    trainingQueue.push({
                        trigger: parts[0].trim(),
                        targets: variants
                    });
                }
            }

            if (trainingQueue.length === 0) return;

            isCurriculumMode = confirm("Enable Curriculum Mode?");
            curriculumLimit = isCurriculumMode ? 1 : trainingQueue.length;

            currentPairIndex = 0;
            consecutiveWins = 0;
            autoLoopCount = 0;
            rewardCount = 0;
            penaltyCount = 0;
            document.getElementById('auto-score').style.display = 'block';
            isAutoTraining = true;
            document.getElementById('btn-auto').innerText = "‚èπ Stop Auto";

            await new Promise(r => setTimeout(r, 100));
            autoTrainLoop();
        }

        async function autoTrainLoop() {
            if (!isAutoTraining) return;

            let currentPair = trainingQueue[currentPairIndex];
            document.getElementById('input').value = currentPair.trigger;
            await send();

            if (!isAutoTraining) return;
            await new Promise(r => setTimeout(r, 100));

            let term = document.getElementById('terminal');
            let text = term.innerText;
            let lines = text.trim().split('\n');
            let lastLine = lines[lines.length - 1];
            let lastResponse = lastLine.replace('Assistant:', '').trim();

            let isStrict = document.getElementById('strict-mode').checked;
            let normResp, targetsNorm;

            if (isStrict) {
                normResp = lastResponse.trim();
                targetsNorm = currentPair.targets.map(t => t.trim());
            } else {
                const clear = (s) => s.toLowerCase().replace(/[^\w\s]/g, '').trim();
                normResp = clear(lastResponse);
                targetsNorm = currentPair.targets.map(t => clear(t));
            }

            // 1. Strict Match: MUST match the SPECIFIC Variant we are teaching right now
            let isStrictCorrect = targetsNorm[currentVariantIndex] === normResp;

            // 2. Soft Match Fix: Check if response contains ANY valid variant from the list
            // (Old code only checked the current variant)
            let isCorrectAny = targetsNorm.some(t => normResp.includes(t));

            document.getElementById('variant-indicator').innerText = (currentVariantIndex + 1) + '/' + currentPair.targets.length;
            document.getElementById('curriculum-indicator').innerText = curriculumLimit + '/' + trainingQueue.length;

            if (isStrictCorrect) {
                // --- PERFECT MATCH (Mastery) ---
                consecutiveWins++;
                rewardCount++;
                document.getElementById('reward-count').innerText = rewardCount;
                await reward();
                await new Promise(r => setTimeout(r, 150));

                if (consecutiveWins >= 3) {
                    consecutiveWins = 0;
                    currentVariantIndex++;

                    let term = document.getElementById('terminal');
                    if (currentVariantIndex < currentPair.targets.length) {
                        term.innerHTML += `<div style="text-align:center; color: #00b8ff; margin: 10px; font-size: 0.8rem;">üîÑ Variant Mastered! Moving to variant ${currentVariantIndex + 1}... üîÑ</div>`;
                        term.scrollTop = term.scrollHeight;
                        await new Promise(r => setTimeout(r, 100));
                    } else {
                        currentVariantIndex = 0;
                        currentPairIndex = (currentPairIndex + 1) % curriculumLimit;

                        if (isCurriculumMode && curriculumLimit < trainingQueue.length) {
                            let totalActions = rewardCount + penaltyCount;
                            let rewardRatio = totalActions > 0 ? (rewardCount / totalActions) : 0;
                            if (autoLoopCount >= 2 && rewardRatio >= 0.85) {
                                curriculumLimit++;
                                currentPairIndex = 0;
                                term.innerHTML += `<div style="text-align:center; color: #ffcc00; margin: 15px; border: 1px dashed #ffcc00; border-radius: 4px; padding: 5px;">üìà CURRICULUM EXPANDED<br>Now teaching pairs 1 to ${curriculumLimit}!</div>`;
                                autoLoopCount = 0;
                            }
                        }

                        if (currentPairIndex === 0) {
                            autoLoopCount++;
                            document.getElementById('loop-count').innerText = autoLoopCount;
                        }

                        term.innerHTML += `<div style="text-align:center; color: #00ffbc; margin: 10px; font-size: 0.8rem;">‚ú® TRIGGER MASTERED! Moving to next prompt... ‚ú®</div>`;
                        term.scrollTop = term.scrollHeight;
                        await new Promise(r => setTimeout(r, 100));
                    }
                }
            } else if (isCorrectAny) {
                // --- SOFT MATCH (Visual Reward + Memory Correction) ---
                // This triggers if the AI said "Hi" but we wanted "Hello".
                // We reward it (don't punish valid English), but we swap the memory to "Hello" to enforce the curriculum.

                rewardCount++;
                document.getElementById('reward-count').innerText = rewardCount;

                let btn = document.getElementById('btn-reward');
                btn.classList.add('flash-active');
                setTimeout(() => btn.classList.remove('flash-active'), 500);

                let term = document.getElementById('terminal');
                term.innerHTML += `<div style="text-align:center; color: #ffcc00; margin: 10px; font-size: 0.8rem; font-style: italic;">üí° Valid Answer! Nudging towards target variant... üí°</div>`;
                term.scrollTop = term.scrollHeight;

                for (let i = 0; i < lastResponseTokenCount; i++) {
                    historyTokens.pop();
                    trainingBuffer.pop();
                }

                // INJECT THE *CURRENT CURRICULUM TARGET*, not necessarily what the AI said.
                let targetTokens = tokenize(currentPair.targets[currentVariantIndex]);
                targetTokens.forEach(w => {
                    let idx = getIndex(w);
                    historyTokens.push(idx);
                    trainingBuffer.push(idx);
                });

                historyTokens.push(getIndex(END_TOKEN));
                trainingBuffer.push(getIndex(END_TOKEN));

                for (let i = 0; i < 3; i++) {
                    trainOnHistory(1.0);
                }
            } else {
                // --- COMPLETE FAIL ---
                consecutiveWins = 0;
                penaltyCount++;
                document.getElementById('penalty-count').innerText = penaltyCount;
                await penalize(currentPair.targets[currentVariantIndex]);
            }

            let total = rewardCount + penaltyCount;
            document.getElementById('mastery-percent').innerText = total ? ((rewardCount / total) * 100).toFixed(1) : 0;

            if (isAutoTraining) {
                setTimeout(() => {
                    clearChat();
                    setTimeout(autoTrainLoop, 100);
                }, 100);
            }
        }

        if ('serviceWorker' in navigator && location.protocol !== 'file:') {
            navigator.serviceWorker.register('./sw.js').catch(console.log);
        }
        window.addEventListener('load', updateTechStats);
    </script>
</body>

</html>